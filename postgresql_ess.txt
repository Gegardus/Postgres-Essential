                                                             PostgreSQL Essential Training

https://medium.com/swlh/learn-sql-joins-once-and-for-all-d5d9078eee7c

GETTING STARTED

Connect to the server with psql

The PSequel shell that we installed in the last movie is a command-line interface for working with Postgres database servers. It provides a quick way for administrators to log into the server and run commands, but it's not the most user-friendly environment for new users since it requires that you know what commands you want to run and how to type them out. However, I do think that it's important to see briefly in order to help reinforce the idea that the client application is completely separate from the database server. And PSQL is a very important tool in the world of Postgres development. So let's go ahead and click on it to start it up. When you first run the tool, it opens up a command-line window and starts the login process. In order to log into a Postgres server, you need to know some connection details. First, it asks for the server location. If you're in a typical office environment where the Postgres server is running on a centralized computer, then you'll need the IP address of that machine. In our case, we're running the server and client on the same physical machine. So we can use the word localhost instead. You can either type that in or simply press Enter and localhost, the default as indicated by the text in square brackets, will be used instead. I'll just leave this blank and press Enter to enter in localhost. Next, it asks you which database you want to connect to. Each Postgres server can hold many different databases. Our server is brand new and there's just one database called Postgres, so I'll log into that one. Again, you can press Enter to accept the default value of Postgres. Next, we need the communication port that the server is listening on. This was set up during the installation step, but is typically left at the default of 5432. I'll press Enter to accept that value. Then we need to provide the user account credentials. Again, during the installation, we created a superuser account named Postgres. So we'll use that. If you've been assigned your own personal user account for your server, you would supply that username here instead. And finally, the user's password. Again, we gave the Postgres user account a password during setup. So I hope that you remember what you filled in during that step. Go ahead and type it in now. When you type, it's not going to appear on the screen, so just type it out and press Enter when you're done. If everything was filled in correctly, you should be connected to the Postgres server and the command prompt will change. Now we can start sending commands to the server. One thing that we can do is get details about the installation. We can do that by running SELECT, version, and then an open and close parentheses. SELECT is a SQL command that returns information, and we're using a built-in function called version to pull out the server version and installation platform information. All these commands are going to finish with a semi-colon to tell the server that we're done typing and to go ahead and execute the statement. When you press Enter, you should get a similar result. I am working with Postgres version 12.2, and it was compiled by Visual C++ on Windows. Another command that we can send is to ask for the current date and time. That uses a function called now. So once again, I'll say SELECT the function now, open and close parentheses and a closing semi-colon. If you were to emit the semi-colon, Postgres doesn't know that you've finished with the command, and when you press Enter, it simply goes down to line number two. You can type the semi-colon here on line number two and Postgres will then execute your statement when you press Enter. That'll reveal the exact time and date that I'm recording this movie. Okay, so we can run commands on the server and get back some information. Let's create a database to work in. We can do that with the CREATE DATABASE command. We'll follow this with the name of the database that we want to create. Let's call it favoritecolors. When you press Enter, it returns CREATE DATABASE that tells me that the database was created successfully. To see a list of all the databases on the server, type backward slash, and then a lowercase letter l. This isn't a SQL command, so you don't need a semi-colon at the end. Just press Enter and you'll see a list of all the different databases that are on the current Postgres server. There is the default Postgres database. We have a couple of template databases, and then we have the database, favoritecolors, that we just created. In order to work with the favoritecolors database, we need to switch into it. Remember that when we logged into the server, we logged into the Postgres database. To switch contexts, use backward slash, C, and then the name of the database, favoritecolors. That tells me that I'm now connected to the database, favoritecolors, as the user Postgres. So we've disconnected from the first database and connected to the second. You'll notice that the command prompt has changed to indicate that the database that we're connected to is now favoritecolors. At this point, we can add a table to this database. We do that with the CREATE TABLE command. The table I want to create is called colors. The name of the table that I want to create is colors, and then I'll open up by parentheses. In order to create a table, we need to define the different columns that will make up the table. The first column in this table will be called ColorID and it'll store integer values, or int. These are just basic numbers. So that defines the first column in the table. I'll type in a comma and the name of the second column in the table. I'll call it ColorName. This color will store text data or character data. I'll type in char. And I want it to be able to store up to 20 characters. So inside of parentheses, I'll in the number 20, and the closing parentheses. That finishes the definition of the two columns for my table. I'll type in another closing parentheses and a closing semi-colon. Let's press Enter. And Postgres tells me that the table was created. With the simple table in place, we can start to store some data into it. To do that, we use INSERT INTO. I'm going to INSERT INTO the colors table, and I'm going to insert some values. This will allow me to add rows of data to the table. I'll open up a parentheses and the first row will be the number one followed by the text, red. Text in Postgres is going to get entered inside a single quotation marks. So there is my first row. I'll close out the parentheses, type in a comma, open a parentheses, or we can type in the values for the second row of data. This will be two and the text, blue. Let's add one more. The number three followed by the text, green. That finishes the INSERT INTO statement. So I'll close the semi-colon and press Enter. Postgres tells me that three records were inserted. And now I can review that information by typing in SELECT * FROM colors. This command asks for everything from that table. I mean, you can see that the table is made up of two columns and that it contains three pieces of data. So what we've just done is write out several commands in a language called Structured Query Language or SQL. And it's the primary way that database developers and users will interact with relational databases. We're going to see a lot of SQL commands throughout this course, and I'll walk you through how they work in more detail as we progress. So don't worry about all of these specific commands in syntax right now. At this point, just understand that we can send commands to the database server through the text base interface provided by the PSequel command-line tool. If you would like to review any of the commands that I just ran, you'll find them in the exercise files, Chapter 1 folder, and it'll be a file called psql-complete.txt. Then when you're done exploring the interface, go ahead and simply close the PSequel command window.

Browse the server with a graphical interface

In addition to the command line psql application, we can use a graphical interface to work with our Postgres server. I've gone ahead and pinned it into my start menu and it's called pgAdmin 4. This is one of many different interfaces that we can choose from. And since it comes with our installation, it's an easy application to start using. PgAdmin will run right inside of your default web browser. So I'm going to choose to use Google Chrome. But you can choose a different web browser if you prefer and I'll say Okay. That'll load up the application here on its own page and allow us to set a Master Password. Doing so it'll allow you to save login passwords to the different servers that you connect to and will allow the application to log in for you each time that you open pgAdmin. For people that connect to lots of different database servers, this can save a bunch of time. I'm going to create a password for that right now. Once you've done that it starts up the application. And on the left hand side of the screen, we have a list of different servers that were connected to. This little pop up window that just appeared over here on the right is part of the Chrome browser. And it's asking me to save that password. I'm just going to say Never to this. Then let's go back over to the left and take a look at the browser pane and expand these servers. Right now we're just connected to a single server and that's our default Postgres server. So I think it will prompt you for the password for the Postgres user account that we created when we installed everything. This might be different than the master password that you just created. Let's go ahead and type in that password. I'll say OK and that'll log me into the database server. Once you've logged into the database server, you shouldn't be prompted for the user password again, since it'll automatically be provided by pgAdmin whenever you launch the application and supply the Master Password moving forward. So with all of the login stuff out of the way, we can start to explore the server. Inside of the server, we have three different collections One for databases, one for login and group roles and one for something called tablespaces. If you expand the login collection, you'll see all the different login accounts that come with our database server, including the Postgres user that we're currently logged in with. These other user accounts are used for system tasks, such as pg_execute server program here at the top. Later, we're going to add additional users so that we can better control who has access to what information. Right now as the Postgres user, we have access to everything on the server. Let's go ahead and minimize this group and expand the databases group. In the databases collection, you're going to find two different databases, the default Postgres database that's created on all Postgres servers and the one that we created for our own favorite color data using the psql application in the previous movie. If you click on the favorite colors database that'll move you into that database and we can explore it contents. Open up the schema group here at the bottom and then expand the public schema. Inside of here we'll find another group for tables. So let's go ahead expand that. And we'll see the colors table that we created. Inside of the colors table, we can see the different components that make up the table. If I expand columns, we'll see that the table includes two columns, one called Color ID and the other called Color Name. If I expand constraints, indexes, rules and triggers, you'll see that we don't have any contents inside of those. These are all different components that control how the table functions in the database. If you want to see what data the table contains, right-click on the table name Colors, choose View Edit Data and then click on All Rows. That runs a select query here at the top of the screen and shows me the results down below. We can see that this table currently has three rows of data, one for red, blue and green. Now before we go any further, I want to make a couple of changes to my interface to make things a little bit bigger on my screen so that they're easier to see. In the Chrome Browser, I'll come up here to the upper right hand menu and I'm going to change the zoom value up to 125%. Then I'm going to go to the File Menu in pgAdmin and choose Preferences. From here, I'm going to scroll down into the Query Tool Preferences and find the Editor. I'll click on that and then change the font size up to 1.5. I'll press Save. And then I'll change the font size in the Query Editor so it's easier to see the different commands that we're executing. Hopefully that makes things a little bit easier to see. I'm going to make this a little wider so you can see the full browser window. So this is our favorite colors database we created using the psql command line tool.

Challenge

CREATE DATABASE favoritefruit;
CREATE TABLE berries (BerryID int, BerryName char(50), BerryColor char(30))
INSERT INTO berries ("berryid", "berryname", "berrycolor") 
VALUES (1, 'blackberry', 'black'), (2, 'raspberry', 'red'), (3, 'blueberry', 'blue');
SELECT * FROM berries;

INTRODUCTION

PostgreSQL native data types

When we created our first tables in Postgres, you might remember that we had to name each column and pick a data type for the information that each column will hold. Let's discuss the role that data types play and the design of your tables. If we take a look at the books table again, you'll notice that each column is storing the same kind of information all the way down. The book ID is always an integer. It's never text, it's never a fraction, it's always going to be a whole number. The book title will always be text, as will the author column, and the publication year will always be an integer just like the book ID. Because we know with certainty what kind of information will be stored in each column, that becomes an important component in the design of this table. Postgres supports a wide variety of data types that you can use to control what kinds of information can be stored in each column of your table. We can group them into categories such as numeric values, character or text values, date and times, monetary amounts, binary data types for storing files, the Boolean type for simple yes or no or true false information, and geometric types for points, lines, polygons, and other shapes that you might use for creating maps. There are many other data types that Postgres supports out of the box, but I want to focus on the three most common numeric, character and date time. The numeric types are used for storing numbers. When you only need whole numbers with no fractional component. You can choose between integer, smallint, or bigint, depending on the range of values that you need to store. The integer data type will allow you to store numbers between approximately negative two billion up to positive two billion and it should be the default choice for when you need to store integer values. If you try and store a value that's outside of the accepted range, Postgres will return an error. When your numbers include fractions, you'll need to either use the numeric or decimal datatype. Both of these are identical and allow the database designer to specify exactly how many digits before and after the decimal point the column will allow by specifying a precision and a scale for the number. For instance, the number 123.45 includes five total digits with two of those to the right of the decimal point. This would require a numeric data type with a precision of five and a scale of two, or a numeric five two data type. And finally, there are two data types for storing floating point values that are commonly used in data science applications to manage extremely large and extremely small numbers. When your table columns need to store a character data, you have a number of options here as well. When all of the values in a column will be the same length, use the character or the char data type. Inside of the parentheses you'll specify the number of characters that the column will hold. This is great for things like two letter state abbreviations or a 16 digit credit card number. Anything that you know will always be the same length is a good candidate for the character or the char data types. When you need to store text that doesn't have a fixed number of characters, then you'll want to use the character varying or the varchar datatype. This will be the best choice for storing our book titles and the author names. Here the number in parentheses indicates the maximum number of characters that the column can hold. Often picking a suitable number of characters will be a guessing game. You want it large enough to hold every value that you're likely to ever put into the column, but not so large that it's ridiculous. At the time of this recording, the Guinness Book of World Records says that the book with the longest title includes just over 26,000 characters. So if you really wanted to store that book, in our database you'll need a varchar 26,021 to hold it all. And when you want to store text of unlimited length, use the text data type. Text is perfect for things like blog posts, and newspaper articles. Finally, let's take a look at the date and time data types. These are pretty straightforward. The date data type will store dates accurate to the day for any date between 4713 BC and the year five million AD. So we have a bit of time before we run out of dates that you can store in a Postgres database. The time data type will store the time of day and is accurate to one microsecond. The timestamp data type will allow you to store both time and date in a single column. And finally, the timestamp with timezone data type adds timezone awareness to the dates so you can perform more accurate comparisons of date and times from around the world. So those were the most common data types that you'll use for storing numeric, character or a date and time values in your Postgres databases. If you're interested in exploring the full list of natively supported data types, I'll point you to chapter eight of the official PostgreSQL documentation, which you can find at this URL. Here you'll find a handy reference to the different types. And as you click through the different links, you'll find more information about how to apply each one inside of your databases.

Join tables together with relationships

PostgreSQL is a relational database management system. And that word, relational, is an important description. It's what makes a Postgres database more than just a collection of spreadsheets. In order to understand how table relationships work, let's take a look at our books table again. Let suppose that you also want to keep track of the birth and death dates of each author. You might try and add two columns to the books table to store this information. The problem with this is that the author birth and death dates don't really describe the topic of this table, they just describe the authors. Worse, if you add another book by the same author, for instance H.G. Wells also wrote "War of the Worlds" the author birth and death dates would get repeated in the database. This causes a wasteful duplication of data and creates a situation where the data could become inconsistent. For instance, if each of these books by H.G. Wells listed different author birth and death dates you wouldn't know which ones to trust. So it's not a good idea to store these pieces of information in the books table. The solution is to create another table that's just about authors. We'll need the author name and their birth and death dates, as well as another primary key for this table to make sure that we can keep each author separate from every other author. Now I can find out who wrote what book, as well as the time when they were alive. There's one more piece to this problem though. Remember back when we talked about the primary keys in the books table? I mentioned that it might be possible for two different authors to have the same name. Well that still applies here. So when I look up the birth date of the author of "The Time Machine" I want to make sure that I have the right H.G. Wells. So instead of storing the author's name in the books table, it would make sense to refer to the primary key from the author's table, instead of the name. I'll make that change to the books table and you'll see that it makes no difference on our ability to figure out who wrote what book. Now it says that "The Time Machine" was written by author 101, I take that piece of information to the authors table to find the name, birth, and death dates. What we've just created is a relationship between these two tables. The author ID in the authors table is a primary key for that table. The author ID in the books table refers to the authors table for additional information about each book. In the book table, the author ID column is called a foreign key. And that's the basic arrangement of what makes a relational database, multiple tables separate information out by topic, but would allow information to be cross referenced by following a thread between matching values in the primary and foreign key columns. This design allows a Postgres database to efficiently store data with a minimum of redundancy while protecting against inconsistencies that can make a dataset untrustworthy.

BUILDING A DATABASE

Organize tables with schemas

When we dig into the pgAdmin browser interface to explore the contents of a postgres server, you'll find the tables that we created so far are underneath a collection of items called schemas. For instance if we expand the favorite colors database and then go into the schemas collection here, we have a single schema called public. And inside of there is where we're going to find the folder for tables and then finally our colors table. Schemas are a way to organize and group objects in your database. So this table, the colors table is more specifically the colors table in the public schema. You can see that if you right click on the table and choose view edit data, all rows. The select query that's generated by PgAdmin includes the two part name for the table that includes the schema name. This is called the tables qualified name. We did include both the schema and table names separated by a period. As a database designer you can create whatever schemas you want to help organize your database. You can think of them as categories. Often schemas are created that mimic the different departments in a business. For instance you might have one schema for the human resources department. Inside of there you would create a table for your employee records and performance reviews. A second schema can be created for the warehouse operations. Then include tables related to inventory, parts management and the shipping component of the business. Not only does this help organize the contents of the database but schemas can also help secure the server and make managing user permissions easier. For instance you can give the human resources manager the ability to view and modify the tables in their department all at once, by granting access permission on the schema and simultaneously prevent them from accessing anything that's in the warehouse schema by denying permissions over there. The public schema that we have in our current databases are the default schema that come with every new postgres database. It's automatically set as the schema for new tables that aren't specifically created in a different schema. Also all database user accounts will automatically have access to the tables in the public schema. If your database will have a large number of users and separation of resources is a concern then it makes sense to think through your schema organization and implement it early on in the design process. Let's create a new database that we can continue to develop throughout the rest of this course. I'm going to go ahead and collapse the favorite colors database and close this tab that's open up on the screen. Then I can either right click on the server or the databases collection and choose create and database. We're going to create a database for a company called Kinetico. Kinetico manufacturers and sells solar panel equipment and other electronic devices. I'll name the database Kinetico and press the save button to create it. Now we can go into the Kinetico database and find these schemas collection. I'll expand it here in the browser window and then come down to schemas. Right now we just have the one schema the public schema that's default. To create a new schema, right click on the schemas collection choose create and then schema. Now we can begin to develop the organizational framework for this database. On the general page, I'm going to name this schema manufacturing. I'll leave the owner account set to postgres, my current user account. On the security and the default privileges tabs is where you would go to assign user accounts to the schema in order to grant access permissions. We haven't set up any additional user accounts yet so let's just leave these alone and move over to the SQL tab. This is the syntax that will be sent to the postgres server to create the new schema. You can see it's pretty simple. We're going to create a schema called manufacturing and it's going to be with the authorization of the postgres user. This second line is setting up the owner of the schema. And since we're logged in and using the postgres user account, we're automatically assigning ownership of the schema to ourselves. It's always a good idea to review the SQL syntax so that you can start to get familiar with the exact commands that the server is running in order to perform these tasks in postgres. The PgAdmin interface that we're using gives users a lot of assistance in creating these commands through the options in the dialog windows like this one. But as you gain experience working with postgres databases, it'll be much easier to simply type these kinds of commands in on your own. When you're ready go ahead and press the save button at the bottom of the window to create the new schema. And you'll see it over here in the browser window. Let's create one more schema by typing in the commands ourselves. Head up to the tools menu and choose the query tool. That'll open up a new tab in the interface and we can start issuing commands directly to the server. Now just type out the code to create a second schema called human resources. It'll read create schema human resources with an underscore between the two words authorization postgres. When sending commands to the postgres server by writing out a query, it's a general practice to use all capital letters for the command keywords and all lowercase letters for the names of objects such as our schema and our username. The PgAdmin interface also recognizes keywords and colors them in a purple font to make the code easier to read. Also remember that all of your commands should end with a semicolon. After typing this out, press the play button on the toolbar to execute the command or you can press the f5 shortcut key on your keyboard. In the messages window at the bottom of the screen you should get a message that the query was successful. This means that the postgres server received the command, understood what it needed to do and was able to perform the requested task. Sending commands in this way doesn't always cause changes to appear in the browser window on the left of the screen though. So you might need to right click either the schemas collection or the database and choose refresh. That should refresh the list and you should see the new schema up here right there. So there's our second schema created by our query. Now we can start to organize the Kinetico databases tables into the appropriate schemas.


Create a table with pgAdmin

Now that our Kinetico database has a couple of schemas, we can start adding data tables into them. If your query window is still open from the previous movie you can go ahead and close it using the X in the upper right-hand corner of the screen. Now to create a table inside of the manufacturing schema, I'll right click it, point to create, and then choose table from the popup menu. Make sure you're choosing this option for table and not this one up here that says foreign table. This one's for creating a link to an external database. I'm going to create a table inside of the manufacturing scheme called products. We'll assign it to the Postgres user account and make sure it's in the schema manufacturing. If you need to make a change, you can use this dropdown menu to choose a different schema. The table space option references the location on our hard drive where the files for this data table will get saved into. When we set up the Postgres server, we created a default location for these files so you could either leave this blank or choose the pg default option from the popup menu. Both actions will have the exact same result. The partitioned option will allow you to split the table across multiple physical files on your hard drive. This can be useful for data tables that are expected to become very large. By placing portions of the data on different hard drives, you can increase the read and write performance of the database. I'm just going to leave this set to no. That finishes the general details. Let's move over to the columns tab. This is where we'll set up the column definition that'll make up the table's structure. Click on the plus button on the right-hand side to add in your first row. I'm going to create a column named product ID. This column will be an ID number that Kinetico uses for each product. They give each product an ID that combines text and a serial number into a unique code for each project that they manufacture so we're going to go ahead and use that in this table. These codes are up to 10 characters in length but can be shorter so I'm going to set this as a character varying data type. You can start typing in the data type box here and then select it from the popup menu when you see it. For the length or precision value, I'll change this to 10. Now incidentally, you might notice that many of the data types in this dropdown menu include options that have square brackets after them. For instance, here's character varying and then here's another option for character varying with an open and closed square bracket. The ones with square brackets will create a column that can store an array of multiple values which can be useful in databases used for application programing. In our case, make sure that you're sticking with the standard version of each data type, the ones without the brackets. So this product ID value will uniquely identify each product, we can use this as the primary key for the table by turning on this switch over on the right. The other switch, the one that says not null, determines whether we will allow this column to be left blank when we enter in a new record. It's probably not a good idea to enter in a product without knowing its product ID, so I'm going to turn this on as well so that we require a value to be supplied when the record is added to the table. So that finishes the first column of the data table. Let's add in a second column. This one will store the product name. Once again, it's going to be a character varying data type and for this one, I want to allow up to 100 characters in length. I also do not want to allow null values or empty values to be stored in this row so go ahead and turn that option on there. I'm going to continue adding in a few more columns to fill out the table's structure. The power column will store the power rating for the product in watts. Now this might not be applicable for every product so I'm going to allow null values in this column by leaving this set to no. Next up we have a column for the manufacturing cost and we'll use the money data type for this. I do not want to allow null values so I'll change this to yes. And finally we have one more column for the category ID. This will store an integer data type. This column will be a foreign key and it'll relate to another table that we're going to create in a moment. Once again, I do not want to allow null values so I'll change this option to yes and that finishes the columns for this table. The constraints tab up here at the top of the screen has a couple of subtabs within it. The primary key constraint has already been filled in for us with the column product ID as the primary key for this table. We do have the opportunity to name this constraint but Postgres is going to give it a name on its own if we leave this blank which is just fine, so I'll leave this option blank. The foreign key constraint will get filled in in just a moment once we have the other table built that it'll reference, so skip this for now and we'll come back to it shortly. We can also add a check constraint to the data table to make sure that values are within a specific range or a unique constraint to make sure that the values are not duplicated across different rows. Let's go ahead and leave all of these options blank for now and move on. The advanced tab includes advanced options that we can enable on the table that might be useful for tweaking database performance. On the partitions table, you can set rules for splitting data up into different physical files. For instance, you can set up a database file on the hard drive for each year and then sales records could get put into the correct file depending on the year that they occur in. Doing so allows you to place current and frequently accessed data on a fast hard drive and older records that don't need to be accessed very often could go onto slower and cheaper storage. The parameters tab includes options for setting up automatic maintenance of the table through a process that Postgres calls autovacuum. If you don't set up a custom configuration, the default values shown below will be applied to the table. The security tab will set up user permissions for read and write access to the table. One of the main reasons that we set up schemas, though, was to control security at the schema level which will apply to all of the tables within the schema. We'll see that later on in the course. Finally, click on the SQL button to see the query that'll be executed on the server to create our table. The code reads that we're going to create a table in the manufacturing schema called products and then we have our columns listed here, product ID as character varying 10 and not null, then we have the name column, power, manufacturing cost, category ID and then finally, we have the primary key declaration and the primary key is going to be created on the product ID column. We're going to be putting this into the default table space and we're going to be setting the owner to the Postgres user account. Press the save button to create our table and it should appear inside of the manufacturing schema. Let's go ahead and expand the tables collection here and there is our new products table. Inside of here, we can take a look at the different columns in the columns collection. There's all the different columns. And if you expand constraints, you'll see the primary key constraint on the product ID. So that's how you use the pgAdmin interface to create a table. Let's run through the process one more time to create a second table inside of the manufacturing schema. Once again, I'll come up here and right click on the manufacturing scheme, point to create, and then choose table. We'll name this table categories. I'll switch over to the columns tab and we'll start adding in our columns for this table. The first one will be category ID. I'll set this to the integer data type. And I want this to be the primary key for the table and not allow null values. We'll add in a second column. This one will be called name. It'll use the character varying 50 data type. I'm not going to allow nulls in this column as well and we'll add one more column. We'll call this one market. We'll set the data type to character varying 20. I do not want to allow nulls here and that finishes the three columns for the table. At this point, we can just straight over to the SQL tab to review the code and there it is right there and press the save button to create the second table. And there is our categories table inside of the manufacturing schema. So now we have two tables in the Kinetico database's manufacturing schema and they're ready to store data. The pgAdmin interface simplifies the process of selecting options, but I encourage you to take time and read through the SQL syntax each time you go through this process in order to get used to the commands that create the tables and establish the columns parameters.

Enforce referential integrity on related records

We've created a schema, inserted some tables and established a relationship between the categories and the products table inside of the Kentico database. Now let's test out the entire system by adding in some data. I still have the Query Tool open from the last movie, but if you close it, you can get it back by selecting anything in the Kentico database, and then coming up to the Tools menu and choosing Query Tool. Now let's start by taking a look at the categories table by executing Select star from manufacturing.categories. Press the Execute button up here on the toolbar to run that query and we'll take a look at the results in the data output window. Here we can see the column structure for the table. Notice the pencil icons at the top of each column. These mean that the table is editable in this view. We can go ahead and add values using the graphical interface here inside of pgAdmin. In previous videos, we used an insert query to add data to a table, but we had to write out the commands manually. This feature of pgAdmin is another example of how the graphical interface can make working with a Postgres database a little bit easier for new users. So let's take advantage of this and fill in some data about the Kentico manufacturing categories. Click in the first cell on this empty row and that'll insert your cursor. This is a numeric integer column, so you can just type in the number one. Press the Tab key to move to the next field in the first row. This is a text field so press the Enter button on your keyboard and that'll open up a text entry window, type in the word batteries, and then press the Tab key to move to the market column. Press the Enter key on your keyboard again, it'll open up another text window and then type in the word domestic. Then, press the Tab key to finish that text entry and that'll move your cursor down to row number two. I'm going to continue entering data on five different product categories. After the last row press the Tab key one more time, that'll move you down to the last blank row. So I entered in the values one, batteries domestic two, grid tie inverters industrial, three, light bulbs domestic, four, solar panels industrial and five, wind harvesters industrial. When you're done entering all of these values, the values should be in a bold font. This is a visual indicator that these values have not yet been saved into the data table. On the toolbar, click the button that looks like a spreadsheet with a downward pointing arrow. This will save the changes into the database. Now you'll notice that the font has changed to a regular font instead of a bold font. The shortcut for the button to save the changes is f6 on your keyboard. That adds in five records into the categories table. Let's do the same thing with the products table. I'm going to come up here and change the query to select star from manufacturing.products. Then I'll execute the query and we'll see that table structure. Now I'm going to add any record to this table. I entered in the values KE5 for the product ID, KECO mini for the name. It is a five watt power item. It is a $16 and 25 cent manufacturing cost and it's in the category ID number four. This places it in the solar panels category. When you're done typing in these values, press the save data button up here on the toolbar and that'll save the data into the database. Now let's see what happens when we try and put in a product and assign it to a category ID that doesn't exist in the categories table. I'll start my product on line number two. For this row, I have the product ID KE48 Li it is a KECO 48 Volt Lithium Ion solar battery. Let's go ahead and make this a little bit wider so you see the full length there. It does not have a power rating, so I left that field null, and the manufacturing cost is $3500. For the category ID, I input a value of 10. Now remember that we don't have any categories in the category table that has a value of 10. Watch what happens when I press the Save Data button up here on the toolbar. I get this error message down here on the bottom of the screen and also notice that the font is still bold. If you take a look at the messages window, we can see some more information about the error. Postgres says that there's an error with what we're trying to do. Specifically, the values that we're trying to save into the database violate the foreign key constraint because there is no category number 10 in the related table. So our foreign key constraint is protecting the integrity of the data by not allowing you to save a record that doesn't make sense. If you wanted to add a product with this category ID number, you have to first create the category. In this way, the data stays trustworthy and the relationships are strictly enforced. I'm going to go back to the data output window and change this category ID to number one, and press Enter and now we should be able to save it into the database. Now when we created the foreign key constraint, we enabled a setting called on update cascade. Let's see what that does in action. First, let's return to the categories table. I'll change the select statement up here at the top and execute the new statement and there is the categories table. I'm going to make a change to the category ID number one, let's go ahead and double click on it to activate it. I'm going to change this from one to 100. Let's go ahead and press enter, and then save the changes to the data table. I didn't get any errors this time, so that's great. Let's go ahead and look back at the products table again. When I execute the query, you'll see a change here in the category ID for our second product. The change that I made was cascaded to the related products table. Our data was automatically updated here as well so that the relationship between the records is maintained. This happened without us having to re link the data in the relationship or update the value manually. The Postgres database engine helps keep records together thanks to the relationship that we created between the foreign key in this table and the primary key in the categories table.

Challenge

CREATE TABLE human_resources.employees (employee_id, first_name, last_name, hire_date, department)

CREATE TABLE human_resources.departments (department_id, depratment_name, building)

RETRIEVE INFORMATION WITH QUERIES

MANAGING DATA

DB ADMINISTRATION

User accounts and roles

Securing data is one of the most important responsibilities of a database management system like Postgres. Controlling who has access to perform which tasks in a database is done through a mechanism called Roles. Roles can be thought of as the user accounts that people use to log in to the server with. In fact, in older versions of Postgres, there were actually two different kinds of accounts, Users and Groups. But since Postgres version 8.1, both of those entities have been combined into a single entity called a Role. Now, in the PgAdmin interface, there's a collection for login and group roles. But there's actually no difference between the accounts intended for a single user or accounts intended for a group of users. Let's open up this collection and take a look. Here you can see that there are already a number of roles that have been created on the Postgres server. All of the ones that start with "PG_" are default roles that grant access to specific system components or settings. For instance, the ability to read settings or statistics from the server, or the ability to write server files. These roles can be granted to other users so that they can perform these specific tasks. This allows system administrators to be able to control who can see what settings are enabled, who can actually change a setting, and who can't see any of that information at all. The other role that's in this collection is the Postgres role. This is the superuser account that we've been using to log in to the server with. The superuser has the ability to create and do anything on the server, so it has the most privileges of any user account. This includes the ability to create new roles and assign permissions. For this reason, extreme care needs to be taken with the superuser account, and its password needs to be carefully guarded. Right-click on the Group Roles collection, point to Create, and choose Login/Group Role. I'm going to create a new role called hr_manager. On the Definition page, we can give this user a password. If you want users to be able to log in to the server, you can add that password. I'm just going to type in "123." If you don't allow them to log in, the role can be used as a group role. You can think of that as a parent role that other user accounts are added to in order to more easily manage permissions across a number of individual database users that share the same responsibilities. You then have the option to set an expiration date for this role. This will prevent it from being used after a certain about of time. And then you can also say how many connections this role can have on the server at one time. The default, negative one, indicates that this role can have an unlimited number of simultaneous connections. Next up is the Privileges tab. Here we can allow or disallow the user to log in. I'm going to go ahead and change this user to "Yes." We have an option to make this user a superuser or give the permission to create roles or databases on this server. And we have the ability to inherit rights from parent roles. This is useful if this role is going to be added into a group. This option is useful if this login role is going to be added into a group role. Next up we have the Membership tab, where we can add individual members to this role, and then we have two tabs for even higher level control over the parameters or the security of this role. As always, the SQL tab shows the commands that will be executed on the Postgres server to create the role, and you can either review the code or go back through the tabs to make any changes. When you're ready, go ahead and press the save button, and the new role is created in the server, we can see it over here in the group. If you ever want to make changes to the role, you can right-click on it, go into Properties, and it puts you right back into the same dialogue window. I'll press the Cancel button here to dismiss it. So that's how you create a user role in the PgAdmin interface. Next, we're going to take a look at how we can secure the database by assigning different permissions to this role.

Grant privileges to a role

We just created a new user role called HR manager and now I want to use this role to help secure the database. I'm going to open up a new query tool, oh and it looks like it's deactivated. So I need to make sure that I select something inside of the KinetEco database. Then I can come up to tools and choose query tool. Now I have a script saved to my clipboard from the exercise file so I'm going to paste that all in here and we can go through it line by line. At the very top we have a comment and sequel comments are indicated by the two hyphen characters so line number one is just for your information it's not actually going to be run. Then on line number two and three we have our standard select statements or we are viewing everything from the manufacturing dot products table or the human resources dot employees table. Now if I just press the execute button up here on the toolbar Postgres is going to run through every line in this script. Instead what I can do is run individual lines by highlighting them first and then pressing the execute button. So this will execute select star from manufacturing dot products and I see the products table or I can highlight line number three and run that and see the human resources dot employee table. So that's the current state of our database as viewed by the Postgres super user account. Let's now impersonate the HR manager by running line number six. When I do that Postgres is going to start treating me as the HR manager and I can see what the database looks like from their perspective. Now let's try and select everything from the manufacturing dot products table again. This time I get an error that says permission is denied for schema manufacturing. If I run line number three I get a similar error that the permission is denied for schema human resources. So right now the HR manager account doesn't have permission to do very much in the database. Let's go ahead and run line number nine to reset my role back to the Postgres user account. Now we can start setting permissions for the HR manager. Let's go ahead and scroll down and we'll find line number twelve. I'm going to grant usage on the schema human resources to the HR manager. When I execute the statement the grant is successful and now we can go back up and take a look at what the database looks like as the HR manager again. I'll run line six that'll treat me as the HR manager and now I can select everything from the manufacturing dot products table. I still don't have access to that schema but if I run line number three you'll see that I still get an error but the error message has changed. It now tells me that permission is denied for the table employees. So while we have access to the schema we don't have access to the table. Let's reset our role again on line number nine. Then we'll come down and take a look at line number thirteen. It says grant select on all tables in the schema human resources to HR manager. Let's go ahead and execute this line. Then we'll go back up to the top I'll switch back into the HR manager role and we'll select everything from the human resources dot employees table. Now we can successfully view information from the table but we just granted select permission the ability to read the data. We didn't grant permission to actually edit any data. For instance if I go down in this table and try and add in a new record we'll come to the very end and I'll type in a new record. When I try and save this data I'll get an error message that permission is denied for the table. So the HR manager can view data but they can't edit it yet. Let's reset our role back to Postgres. It's going to tell me that the data has been modified but not saved. Do I want to discard the changes I'll say yes to that. Then we can go ahead and make sure our role reset and add some additional permissions to the HR manager. Now we could go through on line number thirteen and grant we've already granted select but we could grant insert or grant delete on all tables but what we can also do is run line fourteen. Grant all permissions on all tables in the schema human resources to the HR manager. I'll run that, then test everything out again. We'll reset our role back to HR manager we'll select everything from the human resources dot employees table and now we'll try and enter in a record. This time when I save the data the data is saved successfully. So that's how you can grant permissions to different user roles inside of Postgres. If you want to undo all of those changes and remove the HR manager login role, what we can do is reset our role back to the Postgres user. Then I'll scroll back down here all the way down to the bottom and we can start undoing these changes. On line number eighteen I'll revoke all on all tables and schema human resources from HR manager. Then will revoke usage on the schema and finally we can drop the role HR manager. That'll remove the role from the list and if I right click over here in the browser window and choose refresh you'll see it's no longer listed. So that's how roles work in Postgres you can assign permissions to any level of the database to allow people to be able to read, write, update or delete data as needed by their specific area of responsibility within your organization. By giving people just enough permission to perform the tasks that they need for their job but not letting them perform tasks that they aren't authorized for you help protect the valuable data stored in the database.

In the following command

 GRANT _____ ON ALL TABLES IN SCHEMA financials TO data_analyst

keyword ALL

  GRANT ALL ON ALL TABLES IN SCHEMA financials TO data_analyst

will give the data_analyst role the ability to view, update, add, and delete data in the financials schema.

The opposite of a GRANT command is REVOKE.



Back up and restore a database

The Postgres server does a lot of work to help you manage your data but it can't do much to prevent hardware failures or natural disasters from occurring. Eventually a hard drive will die or your computer will crash and cause catastrophic damage to your database. You need to be prepared for that eventuality by having a back-up strategy in place that makes sure that your data is safe. To create a back-up for your Postgres database right-click the databases name in the PGADMIN browser window and then from the pop-up menu, choose back-up. The first thing we need to do is to find a file name where this will get stored on your computer's hard drive. Click the ellipses button over here on the right that will open up a select file dialogue box and I'm just going to save this into the chapter six folder of the exercise files. Up here on the little URL bar I'll give the file a name. I'll call it kinetico april back-up. At the bottom of the screen we can choose a file format or the file extension, either SQL or back-up, it doesn't really matter which of these two you choose. I'm just going to choose the back-up option so that it's easy to recognize on my computer. Go ahead and press the create button and that will move you back into the back-up dialogue box where we can continue on with he different settings. For the format, the TAR option is going to create an archive file and it's probably the most common choice for most users. Then we need to make sure we go over to the dump options page. This is where you'll specify exactly what the back-up contains. At the top are three switches. One for pre-data, and this includes the table structures and schemas of the database. Next we have one for data and that's exactly what it sounds like. It's all of the data from your data tables and then finally we have post-data. Post-data is for things like indexes. You can choose to include any or all of these items. For a complete database back-up, you'll want to add all three to the back-up file. After that you have some options for things to exclude from the back-up. For instance you can exclude data table and schema ownership or privileges from the back-up. The default is to keep those kinds of settings in the back-up file. There's a number of additional customization settings that you can move through if you'd like. These can be used to dial in a more targeted back-up. For large databases it makes sense to take regular back-ups for things that change often and then periodic back-ups for things that are less mission-critical or things that change infrequently. But what we've turned on at the top, these three switches, are enough to give us a good, solid, complete back-up of our database. Let's press the back-up button and the file will get written to our hard drive. Once that's done, we can copy it to an offsite location to keep it secure. If you want to verify that this finished successfully we can go ahead and take a look on our hard drive. Inside of the exercise files folder I've got my chapter six folder and there is the new back-up file that we just wrote. So when disaster does strike, you'll also want to know how to restore your database from the back-up file. Let's go back into PGADMIN and I'm going to collapse my kinetico database then right-click on the databases folder and I'm going to create a new database. I'm going to call this one new kinetico. I'll press the save button and that will create a new database on my database server. Now right now it doesn't have anything in it. If I expand the schemas, it just has the one public schema with no tables in there. In order to restore the database back-up I'll right-click on this new databases name and choose restore from the pop-up menu. The file format that we chose was the TAR file format so I'll leave this option here then we'll click the ellipses button over here to choose our file from the hard drive. There it is there. I'll press the select button then I'll move over to restore options. I'll choose to restore the pre-data. That's the table structures and schemas, the data that's in those tables as well as any indexes. With those three selections made I'll press the restore button then I'll move through the restore process and hopefully finish this successfully. Once that's done we can go ahead and explore the data. I'm going to right-click on the database name and choose refresh. There inside of the schemas are the human resources and manufacturing schema. And let's just verify that the table data is in place. I'll find a table, right-click on it, view edit data and all rows. And there is our data restored from the database back-up. And that's how you create a database back-up and restore the database to your Postgres server. Hopefully you'll never need to make use of your back-up but it's something that you definitely always want to have available just in case.

Start and stop the server

When you're done working in your database, you might be tempted to simply close your web browser and call it a night. But remember that the pgAdmin interface is just a front-end client for the postgres server. The server itself is still running on your computer. This is important when you have multiple users that all connect from remote machines. You'll want to make sure that the server stays up and running even if you're not currently using it. However, when you do want to shut the serer down, you can do that from the little postgres elephant icon that you can find down in the Windows system tray or at the top of the screen in the MacOS menu bar. Simply right click on it and choose shut down server from the popup menu. Then you'll say yes to this dialog box and that'll close everything up and prevent the server from continuing to consume system resources. The next time you start up pgAdmin, it'll automatically restart the postgres database server again, open up the graphical interface, and make the appropriate connections.